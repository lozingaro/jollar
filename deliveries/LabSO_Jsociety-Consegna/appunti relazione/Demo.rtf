{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;}
{\*\expandedcolortbl;;\csgenericrgb\c9804\c9804\c9804;}
\paperw11900\paperh16840\margl1440\margr1440\vieww16560\viewh18280\viewkind0
\deftab720
\pard\tx18091\pardeftab720\ri-7625\qj\partightenfactor0

\f0\b\fs28 \cf2 DEMO 
\b0 \
Il programma si compone essenzialmente di tre tipi di \'93attori\'94: \
\pard\tx18091\pardeftab720\li720\fi-360\ri-7625\qj\partightenfactor0
\cf2 Il 
\b Core
\b0 , un server centrale chiamato cos\'ec in riferimento al 
\i BitcoinCore
\i0 , presente nella pi\'f9 famosa 
\i Bitcoin 
\i0 blockchain, dalla quale abbiamo tratto degli spunti;\
il 
\b Network Visualizer
\b0 , un tool amministrativo che consente di stampare a video lo stato della rete e le informazioni sulle transazioni finora avvenute;\
i 
\b peer
\b0 , che effettuanno tra loro delle transazioni al fine di effettuare scambio di Jollar.\
\pard\tx18091\pardeftab720\ri-7625\qj\partightenfactor0
\cf2 Cominciamo esaminando le operation di tipo 
\i Request Response
\i0  pi\'f9 importanti offerte dal Core: \
\pard\tx18091\pardeftab720\li720\fi-360\ri-7625\qj\partightenfactor0

\b \cf2 aggiungiPeer
\b0 ,
\b  
\b0 permette al nostro applicativo di tener traccia di tutti i nodi presenti nella rete attraverso la creazione di una lista di \'93Peer\'94 (in realt\'e0 i primi due elementi della lista sono riservati al Core e al Network Visualizer). Il Core riceve dai nodi le  informazioni di binding (location e protocol) e la relativa publicKey (appositamente generata da un servizio embedded nominato MyKeyUtil ) ed assegna loro un indice ed un id di sessione. L'indice ha lo scopo di distinguere il nodo che effettuer\'e0 le transazioni (il primo nodo) da quelli che si limiteranno a convalidarle (i nodi successivi), mentre il sid permette al Core di distinguere le varie richieste in entrata mediante una stringa che consente l'identificazione univoca di ciascun nodo.\

\b invioPeer
\b0 , ispirato al 
\i Peer Discovery 
\i0 descritto nella 
\i Bitcoin Developer Guide
\i0 , consente ad ogni nodo connesso di richiedere in qualsiasi momento la lista aggiornata dei Peer connessi alla rete e relative info, quali: publickey, location e protocol. Dato l'esiguo numero di peer connessi nella demo, si \'e8 scelto di restituire una lista che li contenga tutti.\

\b downloadBlockchain
\b0 ,
\b  
\b0 ispirato all'
\i Initial
\i0  
\i Block Download 
\i0 (
\i IBD
\i0 ) del Bitcoin, permette di scaricare una copia della blockchain aggiornata presente nel Core. La presenza del semaforo fa s\'ec che tale download venga effettuato solo dopo l\'92inserimento del primo blocco, in modo tale da scaricare una blockchain non vuota.\
\pard\tx18091\pardeftab720\ri-7625\qj\partightenfactor0
\cf2 Ci soffermiamo ora sulle procedure di verifica e validazione dei blocchi, per le quali \'e8 stato ritenuto opportuno fare distinzione tra il primo blocco ed i successivi, come brevemente sottolineeremo in uno screenshot del codice poco pi\'f9 avanti. La fase di validazione avviene dopo quella di verifica. Analizziamole:\
\pard\tx18091\pardeftab720\li720\fi-360\ri-7625\qj\partightenfactor0

\b \cf2 verificaBMsg
\b0  acquisisce in input un blocco e il rispettivo hash criptato. Nel blocco \'e8 anche compresa la chiave publica del Seller che verr\'e0 utilizzata per la decodifica (ad eccezione della prima transazione in cui la chiave pubblica utilizzata \'e8 quella del buyer). Una volta calcolato l'hash del blocco, la publickey permette all'operation 
\i verifica 
\i0 di 
\i MyKeyUtil 
\i0 di decodificare l\'92hash criptato e confrontarlo con l\'92hash in chiaro. Se i due hash corrispondono, in una variabile booleana viene salvato il valore 
\i true
\i0  e si procede alla successiva fase di validazione, altrimenti la variabile assume valore 
\i false 
\i0 e il blocco viene rigettato. \

\b validazione
\b0  viene eseguita solo se la verifica al punto precedente d\'e0 esito positivo. Vengono effettuati due test. Il primo avviene attraverso il 
\i piccolo Teorema di Fermat
\i0  e consiste nel verificare che il numero inviato nel blocco sia uno pseudoprimo. Se lo \'e8, si procede col secondo test, che confronta l'hash dell'ultimo blocco presente nella blockchain con il 
\i previousBlockHash 
\i0 contenuto nel blocco ricevuto. Se anche questo test viene superato, il blocco viene aggiunto in coda alla blockchain.\
\pard\tx18091\pardeftab720\ri-7625\qj\partightenfactor0
\cf2 \
Le principali differenze che contraddistinguono la validazione del primo blocco rispetto a quella dei successivi sono:\
\pard\tx18091\pardeftab720\li720\fi-360\ri-7625\qj\partightenfactor0
\cf2 il primo blocco non ha un blocco che lo precede, pertanto il 
\i previousBlockHash
\i0  assume un valore di default, ovvero l'hash della stringa "
\i 0
\i0 ";\
se vengono passati tutti i test, si incrementa il semaforo che permette ai peer di scaricare la blockchain contenente (almeno) il primo blocco.\
\pard\tx18091\pardeftab720\ri-7625\qj\partightenfactor0
\cf2 \
\
\
\
}